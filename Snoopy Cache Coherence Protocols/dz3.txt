=========================================================================================================================
Invalidating protocols
=========================================================================================================================
WTI (Write-Through Invalidate) No-Allocate
----------------------------------------------------------
1) 
Brojevi pristupa operativnoj memoriji od strane naših 4 procesora su sledeći:
	- P0: 3
	- P1: 4
	- P2: 2
	- P3 1
	
Hit rate ću računati kao (numberOfCacheHits / numberOfRequests) * 100%, gde numberOfCacheHits predstavlja broj zahteva
koji su mogli da budu opsluženi pristupajući samo keš memoriji (bez pristupa operativnoj memoriji), a numberOfRequests
predstavlja ukupan broj zahteva upućenih memoriji (nezavisno od toga da li se pristupalo operativnoj memoriji ili ne). Ukoliko se
u ovom protokolu dogodi Write-Hit, tada neću inkrementirati numberOfCacheHits, tj. to neću računati kao pogodak u kešu, zato
što se i tada pristupa operativnoj memoriji. Zato, jedina od ovih situacija (Read-Hit, Read-Miss, Write-Hit, Write-Miss) zbog koje 
ću inkrementirati numberOfCacheHits jeste Read-Hit jer se jedino kod nje uopšte ne pristupa operativnoj memoriji, već se zahtev 
kompletno opslužuje samo pristupajući keš memoriji.

Hit rate-ovi naših procesora su onda za datu sekvencu sledeći:
	- P0: 0/3 (0%)
	- P1: 0/4 (0%)
	- P2: 0/2 (0%)
	- P3: 0/1 (0%)

2)
U koraku 3 se prilikom upisa procesora P1 u blok A0 ažurira operativna memorija, pri čemu se taj blok ne dovlači u keš jer je u 
pitanju no-allocate varijanta WTI protokola.

3)
U koraku 4 se događa Read-Miss zato što procesor P0 ne pronalazi blok A0 u svojoj keš memoriji za čitanje.

4)
U koraku 5 se ne vrši dohvatanje bloka A2 prilikom upisa procesora P1 u taj blok zato što je u pitanju no-allocate varijanta
WTI protokola.

5)
Da bi blok A2 u koraku 5 bio dovučen u keš memoriju, treba iskoristiti allocate varijantu WTI protokola jer se kod nje prilikom
upisa u neki blok koji procesor nema u svom kešu taj blok prvo dovuče iz operativne memorije (BusRd), a zatim se ažurira blok
i u kešu i u operativnoj memoriji (BusWr).

WTI protokol ima loše performanse zato što koristi Write-Through strategiju pri upisu (kod nje je neophodno da se pri svakom 
upisu u bilo koji blok od strane bilo kog procesora pristupi i operativnoj memoriji kako bi ona uvek imala ažurne podatke). Zbog
toga se događa mnogo nepotrebnih pristupa operativnoj memoriji kod ovog protokola.

Ovu pojavu je moguće ublažiti koristeći Write-Back (odloženi upis u operativnu memoriju) umesto Write-Through strategije 
prilikom upisa. Odloženi upis se omogućava uvođenjem koncepta vlasništva. Kada je procesor vlasnik nekog bloka, to znači da on 
jedini ima ažurne vrednosti tog bloka u čitavom sistemu (dakle niti operativna memorija, niti keševi drugih procesora kod sebe 
nemaju ažurne vrednosti tog bloka) - ukoliko taj procesor zatraži čitanje ili upis u taj blok, obe operacije će se izvršiti lokalno
u njegovom kešu bez pristupa operativnoj memoriji. Tada taj procesor ima kompletnu odgovornost za taj blok - ukoliko neki drugi 
procesor zatraži čitanje tog bloka, on treba da mu ga dostavi. Takođe, ukoliko se dogodi zamena tog bloka, procesor je 
dužan da pre zamene uradi Flush, tj. da upiše taj blok u operativnu memoriju kako se ne bi trajno izgubile ažurne vrednosti.
=========================================================================================================================
MSI (Modified-Shared-Invalid)
----------------------------------------
6)
U koracima 3 i 5 se upravo primećuje da se kod WTI protokola koristi Write-Through strategija, a kod MSI protokola Write-Back
strategija pri upisu.

7)
Blok A0 u kešu procesora P1 će nakon koraka 3 preći iz stanja I u stanje M zato što je procesor P1 zatražio upis u ovaj blok, što 
znači da će se upis (nakon dohvatanja bloka iz operativne memorije i poništavanja kopija ovog bloka u keševima drugih procesora) 
obaviti lokalno u njegovom kešu i time će on postati vlasnik bloka - jedini će imati ažurne vrednosti bloka u čitavom sistemu.

P1: I -- (PrWr/BusRdX) --> M

8)
Blok A0 u kešu procesora P0 će nakon koraka 4 preći iz stanja I u stanje S zato što je procesor P0 zatražio čitanje ovog bloka,
što znači da će ovaj blok postati deljen između keševa procesora P0 i P1 (jer je u koraku 3 procesor P1 bio vlasnik ovog bloka, a
sada će nakon koraka 4 i on preći u stanje S i pri tom ažurirati i operativnu memoriju). Procesor P0 može da pročita blok iz
operativne memorije, a može i da mu ga dostavi preko magistrale procesor P1 prilikom obavljanja Flush operacije (u simulatoru
se ovo dogodi).

P0: I -- (PrRd/BusRd) --> S

9)
U koraku 2 dolazi do ažuriranja bloka A0 u operativnoj memoriji zato što je procesor P2 zatražio ovaj blok za čitanje, a nema ga
ni u svom kešu, niti može da ga pronađe u operativnoj memoriji pošto je nakon koraka 1 procesor P0 postao vlasnik bloka. Zato
nakon koraka 2 procesor P0 mora da uradi Flush operaciju prilikom koje ažurira operativnu memoriju kako bi procesor P2 mogao
da dohvati taj blok za čitanje (u simulatoru procesor P2 prilikom Flush operacije dostavi preko magistrale direktno procesoru
P0 blok, tako da ga procesor P0 ne dohvata iz operativne memorije). 

P2: I -- (PrRd/BusRd) --> S

Ovde se uočava mana MSI protokola - kada je neki blok u stanju M i neko drugi ga zatraži za čitanje, uvek se radi Flush, tj. 
ažuriranje operativne memorije. Bilo bi bolje kada bi mogao samo da se uradi transfer bloka preko magistrale u ovoj situaciji
i da se tako uopšte ne pristupa operativnoj memoriji, međutim tako bismo se našli u opasnoj situaciji jer bi u tom trenutku dati
blok bio u stanju S u keševima dva procesora, pri čemu nijedan procesor očigledno onda ne bi bio vlasnik bloka, a u memoriji
blok nije ažuran jer nije uradjen Flush. Sada, ako bi se dogodila zamena bloka u keševima oba procesora, trajno bismo izgubili
ažurne vrednosti bloka jer niko nema odgovornost da u tom slučaju ažurira operativnu memoriju i time bi sistem ušao u 
nekonzistentno stanje. Zato je kod MSI protokola neophodno da uvek memorija bude ažurna kada je blok u jednom ili više keševa 
u stanju S. Sve isto važi i za MESI protokol. Ovaj problem je ublažen kod MOESI protokola uvođenjem stanja O koje ima 
semantiku vlasništva i na taj način omogućava da više keševa deli isti blok a da memorija bude neažurna - tako se uspešno dodatno
odlaže upis u operativnu memoriju i zato je MOESI protokol u ovoj konkretnoj situaciji superiorniji u odnosu na MSI i MESI
protokole.
=========================================================================================================================
MESI (Modified-Exclusive-Shared-Invalid)
------------------------------------------------------

10)
U koraku 2, kada procesor P2 zatraži blok A0 za čitanje, dostaviće mu ga procesor P0 direktno preko magistrale zato što je on
nakon koraka 1 postao vlasnik tog bloka i zato će nakon koraka 2 uraditi Flush operaciju nakon koje će blok u njegovom kešu preći
u stanje S. Jasno je da će kod procesora P2 blok A0 biti učitan u stanju S.

11)
U koraku 3, prilikom upisa procesora P1 u blok A0, on će prvo dobiti tekući ažuran blok od procesora P0 preko magistrale jer
je kod njega taj blok u stanju S (takođe je i kod procesora P2 u stanju S, ali je naravno dovoljno da samo jedan procesor uradi
transfer), pri čemu će procesori P0 i P2 u svojim keševima promeniti stanje bloka A0 iz S u I, a zatim će procesor P1 upisati u
blok A0 samo u svom kešu i promeniti stanje tog bloka iz I u M.

Odlučivanje koji procesor će uraditi transfer bloka u slučajevima kada postoji više keševa kod kojih je blok u stanju S se može
uraditi na više načina:
	* Uvođenjem novog stanja F (Forwarding) u kojem će biti blok samo kod procesora koji je zadužen za transfer tog bloka 
	(MESIF varijanta MESI protokola).
	* Arbitracijom na magistrali.
	* Svi procesori u stanju S stavljaju blok na magistralu (tada je neophodno da magistrala podržava istovremeno stavljanje
	identičnog podatka na nju).
	
12)
Blok A2 će biti u stanju M u kešu procesora P1 nakon koraka 5 zato što je procesor P1 zatražio upis u taj blok, što znači da ga
onda prvo dohvata iz operativne memorije, a zatim upisuje samo lokalno u svom kešu - on postaje vlasnik tog bloka.

P1: I -- (PrWr/BusRdX) --> M

13)
Nakon koraka 5, prilikom čitanja bloka A2 od strane procesora P1 se ne vrše nikakve akcije protokola jer je taj blok kod njega
u stanju M što znači da je ažuran, pa ga on čita iz svog keša bez ikakvog izlaska na magistralu. Čak i da je došlo do upisa od strane
procesora P1 u ovom koraku umesto čitanja, ne bi se izvršile nikakve akcije protokola ni tada.

P1: M -- (PrRd/--) --> M
=========================================================================================================================
MOESI (Modified-Owned-Exclusive-Shared-Invalid)
------------------------------------------------------------------
14)
